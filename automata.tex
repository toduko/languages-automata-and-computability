\chapter{Автомати}

Тук ще разгледаме първата ``машина'', с която ще класифицираме езиците.

\section{Детерминирани автомати и автоматни езици}

\begin{definition}
    \textbf{Детерминиран краен автомат} (накратко ДКА) ще наричаме всяко $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$, където:
    \begin{itemize}
        \item $\Sigma$ е крайна азбука
        \item $Q$ е крайно множество от състояния
        \item $s \in Q$ (ще го наричаме начално/стартово състояние)
        \item $\delta : Q \cross \Sigma \rightarrow Q$ (ще я наричаме функция на преходите)
        \item $F \subseteq Q$ (ще ги наричаме финални състояния)
    \end{itemize}
\end{definition}

В момента със това, което имаме,
ако искаме да покажем къде ще стигнем с думата $aaa$, започвайки от $s$,
ще трябва да го запишем със $\delta(\delta(\delta(s, a), a), a)$, което е тромаво.

За това ще си въведем начин, по който да видим крайният резултат от прочитането на цяла дума.

\begin{definition}
    Дефинираме $\delta^* : Q \cross \Sigma^* \rightarrow Q$ индуктивно:
    \begin{itemize}
        \item $\delta^*(p, \varepsilon) = p$ за всяко $p \in Q$
        \item $\delta^*(p, \beta x) = \delta(\delta^*(p, \beta), x)$ за всяко $p \in Q, \beta \in \Sigma^*, x \in \Sigma$
    \end{itemize}
\end{definition}

Сега можем да забележим, че:
\begin{align*}
    \delta^*(s, aaa) & = \delta(\delta^*(s, aa), a) = \delta(\delta(\delta^*(s, a), a), a) =                           \\
                     & = \delta(\delta(\delta(\delta^*(s, \varepsilon), a), a), a) =\delta(\delta(\delta(s, a), a), a)
\end{align*}
Функцията наистина прави това, което искаме да прави.

\begin{definition}
    Нека $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$ е ДКА.
    Тогава езикът на автомата $\mathcal{A}$ е множеството
    $\mathcal{L}(\mathcal{A}) = \{ \alpha \in \Sigma^* \: | \: \delta^*(s, \alpha) \in F \}$.
    Един език $L \subseteq \Sigma^*$, наричаме \textbf{автоматен}, ако има ДКА $\mathcal{A}$ с $\mathcal{L}(\mathcal{A}) = L$.
\end{definition}

\section{Представяне на автомат}

Ще видим начините, по които можем да представяме един автомат.
За пример ще вземем автомата $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$, където:
\begin{itemize}
    \item $\Sigma = \{ a, b \}$
    \item $Q = \{ q_0, q_1, q_2 \}$
    \item $s = q_0$
    \item $\delta(q_0, a) = q_2$
    \item $\delta(p, x) = q_1$ за $p \in Q, \: x \in \Sigma, \: \opair{p, x} \neq \opair{q_0, a}$
    \item $F = \{ q_2 \}$
\end{itemize}
Това е първият начин за представяне.
При него директно в явен вид се казват кои са всички съставни елементи на $\mathcal{A}$.
Това ще бъде използване сравнително често, когато правим от един автомат друг.
В случаите, в които не знаем как изглежда първоначалният автомат, следващите методи тогава няма да свършат работа. \\

Вторият начин за представяне е с таблица на функцията на преходите:
\begin{center}
    \begin{tabular}{||r | r | r||}
        \hline
        \cellcolor{lightgray} & $a$   & $b$   \\
        \hline
        $\rightarrow q_0$     & $q_2$ & $q_1$ \\
        \hline
        $q_1$                 & $q_1$ & $q_1$ \\
        \hline
        $\checkmark q_2$      & $q_1$ & $q_1$ \\
        \hline
    \end{tabular}
\end{center}
Тук с $\rightarrow$ отбелязваме началното състояние,
а с $\checkmark$ отбелязваме финалните състояния.
Във втората и третата колона казваме къде ще се озовем,
ако се намираме в съответното състояние и прочетем съответната буква.
Това е по-прегледно представяне от първото, но може да стане обемно. \\

Третият начин за представяне е с картинка:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth',thick]
        \node[initial, state, initial text=] (1) {$q_0$};
        \node[state] (2) [above right of=1] {$q_1$};
        \node[state, accepting] (3) [below right of=1] {$q_2$};
        \draw[->] (1) -- node[above] {$b$} (2);
        \draw[->] (1) -- node[above] {$a$} (3);
        \path (2) edge [loop above] node[above] {$a, b$} (2);
        \draw[->] (3) -- node[right] {$a, b$} (2);
    \end{tikzpicture}
\end{center}

Началното състояние е отбелязано със стрелка, а финалните са оградени два пъти.
Представянето чрез картинка изглежда по-прегледно от другите две, но то може и да стане огромно.

Ясно е, че $\mathcal{L}(\mathcal{A}) = \{ a \}$.
Ако искаме да покажем това формално, трябва да направим следното:
\begin{itemize}
    \item Очевидно $a \in \mathcal{L}(\mathcal{A}), \: b \notin \mathcal{L}(\mathcal{A}), \: \varepsilon \notin \mathcal{L}(\mathcal{A})$
    \item Показваме, че $\delta^*(q_1, \alpha) = q_1$ за всяко $\alpha \in \Sigma^*$ с индукция по $|\alpha|$
    \item Ако $\alpha \notin \{ a, b, \varepsilon \}$, то $\alpha = x y \beta$ за $x, y \in \Sigma, \: \beta \in \Sigma^*$
    \item Тогава лесно се вижда, че $\delta^*(q_0, \alpha) = q_1 \notin F$.
          Или директно отиваме в $q_1$ (ако $x = b$) и оставаме там, или първо отиваме в $q_2$ (ако $x = a$), и после със следващата буква отиваме в $q_1$ и оставаме там.
\end{itemize}

Това обаче за такива прости автомати не е нужно.
Тези неща такива случаи ще ги приемаме за очевидни.

\section{Прости примери за автоматни езици}

Автомат за $L = \varnothing$:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth',thick]
        \node[initial, state, initial text=] (1) {$q$};
        \path[->] (1) edge [loop above] node[above] {$a, b$}(1);
    \end{tikzpicture}
\end{center}

Автомат за $L = \Sigma^*$:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,>=stealth',thick]
        \node[initial, accepting, state, initial text=] (1) {$q$};
        \path[->] (1) edge [loop above] node[above] {$a, b$}(1);
    \end{tikzpicture}
\end{center}

Сега малко ще усложним нещата.
Ще направим автомат, който да разпознае езикът от една конкретна дума.
Конструкцията за конкретната дума много лесно се обобщава за всички.
За пример нека направим автомат за $L = \{ abab \}$:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[initial, state, initial text=] (1) {$\varepsilon$};
        \node[state] [right of=1] (2) {$a$};
        \node[state] [right of=2] (3) {$ab$};
        \node[state] [right of=3] (4) {$aba$};
        \node[state, accepting] [right of=4] (5) {$abab$};
        \node[state] [below of=3] (6) {$\cross$};
        \draw[->] (1) -- node[above] {$a$} (2);
        \draw[->] (2) -- node[above] {$b$} (3);
        \draw[->] (3) -- node[above] {$a$} (4);
        \draw[->] (4) -- node[above] {$b$} (5);
        \path[->] (1) edge [bend right] node[below] {$b$} (6);
        \path[->] (2) edge [bend right] node[below] {$a$} (6);
        \path[->] (3) edge  node[right] {$b$} (6);
        \path[->] (4) edge [bend left] node[below] {$a$} (6);
        \path[->] (5) edge [bend left] node[below] {$a, b$} (6);
        \path[->] (6) edge [loop below] node[below] {$a, b$} (6);
    \end{tikzpicture}
\end{center}

Ето как ще обобщим конструкцията за $L = \{ \alpha \}$:
\begin{itemize}
    \item $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$
    \item $Q = Pref(L) \cup \{ \cross \}$ (начален отрязък от пътя, който съставя $\alpha$, $\cross \notin \Sigma$ е отхвърлящо състояние боклук)
    \item $s = \varepsilon$
    \item За $\beta \preceq_{pref} \alpha \: ($тогава $\beta \in Q), \: x \in \Sigma$:
          ако $\beta x \preceq_{pref} \alpha$, то $\delta(\beta, x) = \beta x$,
          иначе $\delta(\beta, x) = \cross$
    \item $\delta(\cross, x) = \cross$ за $x \in \Sigma$
    \item $F = \{ \alpha \}$
\end{itemize}

Идеята зад конструкцията е следната:
Състоянията кодират пътя, който сме изминали, ако не сме се отклонили вече от ``строежа'' на $\alpha$.
В първият момент на отклонение отиваме във нефинално състояние ``боклук'', от което не може да излезнем. \\

Автомат за $L = \{ ab, ba, aa \}$:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[initial, state, initial text=] (1) {$\varepsilon$};
        \node[state] [above right of=1] (2) {$a$};
        \node[state] [below right of=1] (3) {$b$};
        \node[state, accepting] [above right of=2] (4) {$aa$};
        \node[state, accepting] [right of=2] (5) {$ab$};
        \node[state, accepting] [right of=3] (6) {$ba$};
        \node[state] [below right of=3] (7) {$bb$};
        \node[state] [below right of=5] (8) {$\cross$};
        \draw[->] (1) -- node[above] {$a$} (2);
        \draw[->] (1) -- node[above] {$b$} (3);
        \draw[->] (2) -- node[above] {$a$} (4);
        \draw[->] (2) -- node[above] {$b$} (5);
        \draw[->] (3) -- node[above] {$a$} (6);
        \draw[->] (3) -- node[above] {$b$} (7);
        \path[->] (4) edge [bend left] node[right] {$a, b$} (8);
        \path[->] (5) edge node[left] {$a, b$} (8);
        \path[->] (6) edge node[left] {$a, b$} (8);
        \path[->] (7) edge [bend right] node[right] {$a, b$} (8);
        \path[->] (8) edge [loop right] node[right] {$a, b$} (8);
    \end{tikzpicture}
\end{center}

Тази конструкция надгражда над предната.
Вместо да се следи за един възможен път, го правим за няколко.

Ето как ще обобщим конструкцията за $L = \{ \alpha_1, \: \dots, \: \alpha_n \}$:
\begin{itemize}
    \item $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$
    \item $Q = \{ \alpha \in \Sigma^* \: | \: (\exists \beta \in L) (|\alpha| \leq |\beta|) \} \cup \{ \cross \}$ (не гледаме пътища по-дълги от най-дългата дума в $L$, $\cross \notin \Sigma$ - състояние боклук)
    \item $s = \varepsilon$
    \item За $\alpha \in Q, \: x \in \Sigma$:
          ако $\alpha x \in Q$, то $\delta(\alpha, x) = \alpha x$,
          иначе $\delta(\alpha, x) = \cross$
    \item $\delta(\cross, x) = \cross$ за $x \in \Sigma$
    \item $F = L$
\end{itemize}

Коректността на тази конструкция приемаме за очевидна. \\

Нека сега направим автомат за $L = \{ \alpha \in \Sigma^* \: | \: |\alpha| \: \text{е четно} \}$.

За една дума $\alpha \in \Sigma^*$ знаем, че тя или има четна дължина или има нечетна дължина.
Дали не можем да кодираме по някакъв начин четността на прочетената дума в състояние?
Отговорът е, че можем. Автоматът е следния:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[text width=0.5cm] at (-1, 1) {$\mathcal{A}$:};
        \node[accepting, initial, state, initial text=] (1) {$0$};
        \node[state] [right of=1] (2) {$1$};
        \path[->] (1) edge [bend left] node[above] {$a, b$} (2);
        \path[->] (2) edge [bend left] node[below] {$a, b$} (1);
    \end{tikzpicture}
\end{center}

Знаем, че $|\varepsilon|$ е четно.
За всякo $\alpha \in \Sigma^*, \: x \in \Sigma$ знаем,
че $|\alpha x|$ има различна четност от $|\alpha|$.
Така ние започваме с думата $\varepsilon$ и 0 като честност на думата и за всяка буква сменяме четността.

Нека сега помислим как трябва да докажем, че $\mathcal{L(A)} = L$.
За това ще трябва да покажем, че започвайки от $0$ и четейки $\alpha$ ние наистина получаваме четността на $|\alpha|$ като състояние.

\begin{claim}
    За всяко $\alpha \in \Sigma^*$ : $\delta^*(0, \alpha) = |\alpha| \: (mod \: 2)$
\end{claim}

\begin{proof}
    С индукция по $|\alpha|$.
    \begin{itemize}
        \item База: $|\alpha| = 0$, тогава $\alpha = \varepsilon$.
              Наистина $\delta^*(0, \varepsilon) = 0 \: (mod \: 2)$ \checkmark
        \item ИС: $|\alpha| = n + 1$, тогава $\alpha = \beta x$ за $\beta \in \Sigma^*, |\beta| = n, \: x \in \Sigma$
              Тогава:
              \begin{align*}
                  \delta^*(0, \beta x) & = \delta(\delta^*(0, \beta), x) \stackrel{\text{ИП}}{=}
                  \delta(|\beta| \: (mod \: 2), x) = |\beta| + 1 \: (mod \: 2) =                 \\
                                       & = |\beta x| \: (mod \: 2) = |\alpha| \: (mod \: 2)
              \end{align*}
    \end{itemize}
\end{proof}

С това показахме, че състоянията наистина кодират информацията, която искахме да кодират.
Имайки това можем да покажем, че двата езика съвпадат, по следния начин:
\begin{center}
    $\alpha \in \mathcal{L(A)} \iff \delta^*(0, \alpha) = 0 \iff |\alpha| \: (mod \: 2) = 0 \iff \alpha \in L$
\end{center}


Нека сега помислим какъв автомат ще можем да направим, за $\overline{L}$.
Ние вече имаме автомат за $L$.
Единственото, което трябва да направим, е да сменим отговора на автомата.
Ако преди той е казвал ДА, сега да казва НЕ, и обратното.
Очевидно този автомат ще свърши работа:
\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[text width=0.5cm] at (-1, 1) {$\mathcal{A}_{\overline{L}}$:};
        \node[initial, state, initial text=] (1) {$0$};
        \node[accepting, state] [right of=1] (2) {$1$};
        \path[->] (1) edge [bend left] node[above] {$a, b$} (2);
        \path[->] (2) edge [bend left] node[below] {$a, b$} (1);
    \end{tikzpicture}
\end{center}

\section{Операции над автоматни езици}

Сега ще разгледаме няколко операции, които запазват автоматност.
Първата операция (която вече загатнахме) над автоматни езици, която ще разгледаме е допълнение.

\begin{claim}
    Ако $L$ е автоматен, то тогава и $\overline{L}$ също е автоматен.
\end{claim}

\begin{proof}
    Понеже $L$ е автоматен, има ДКА $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$ с $\mathcal{L(A)} = L$.
    Нека $\mathcal{A}_{\overline{L}} = \opair{\Sigma, Q, s, \delta, Q \setminus F}$. Тогава:
    \begin{center}
        $\alpha \in \mathcal{L(A)} \iff \delta^*(s, \alpha) \in Q \setminus F \iff \delta^*(s, \alpha) \notin F \iff \alpha \notin L$
    \end{center}
\end{proof}

Както направихме и в предният пример, тук просто сменяме отговора.
Състоянията и преходите на началният автомат ни дават достатъчна информация за структурата на думата,
което е достатъчно за да кажем дали е от езика $\overline{L}$ или не е. \\

Преди да разгледаме следващата операция ще разгледаме два авомата:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[text width=0.5cm] at (-1, 1) {$\mathcal{A}_1$:};
        \node[accepting, initial, state, initial text=] (1) {$0$};
        \node[state] [right of=1] (2) {$1$};
        \path[->] (1) edge [bend left] node[above] {$a$} (2);
        \path[->] (2) edge [bend left] node[below] {$a$} (1);
        \path[->] (1) edge [loop above] node[above] {$b$} (1);
        \path[->] (2) edge [loop above] node[above] {$b$} (2);
    \end{tikzpicture}
\end{center}

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,>=stealth',thick]
        \node[text width=0.5cm] at (-1, 1) {$\mathcal{A}_2$:};
        \node[initial, state, initial text=] (1) {$0$};
        \node[accepting, state] [right of=1] (2) {$1$};
        \path[->] (1) edge [bend left] node[above] {$b$} (2);
        \path[->] (2) edge [bend left] node[below] {$b$} (1);
        \path[->] (1) edge [loop above] node[above] {$a$} (1);
        \path[->] (2) edge [loop above] node[above] {$a$} (2);
    \end{tikzpicture}
\end{center}

Ще приемем за очевидно, че първият автомат разпознава думите с четен брой $a$,
а вторият автомат разпознава думите с нечетен брой $b$.

Как бихме могли да направим автомат $\mathcal{A}$ за $\mathcal{L}(\mathcal{A}_1) \cap \mathcal{L}(\mathcal{A}_2)$?
Можем да направим така:

\begin{center}
    \begin{tikzpicture}[node distance=2.5cm,>=stealth',thick]
        \node[text width=0.5cm] at (-1, 1) {$\mathcal{A}$:};
        \node[initial, state with output, initial text=] (1) {$0$ \nodepart{lower} $0$};
        \node[state with output] [right of=1] (2) {$0$ \nodepart{lower} $1$};
        \node[accepting, state with output, initial text=] [below of=1](3) {$1$ \nodepart{lower} $0$};
        \node[state with output] [right of=3] (4) {$1$ \nodepart{lower} $1$};
        \path[->] (1) edge [bend left] node[above] {$a$} (2);
        \path[->] (2) edge [bend left] node[below] {$a$} (1);
        \path[->] (3) edge [bend left] node[above] {$a$} (4);
        \path[->] (4) edge [bend left] node[below] {$a$} (3);
        \path[->] (1) edge [bend left] node[right] {$b$} (3);
        \path[->] (3) edge [bend left] node[left] {$b$} (1);
        \path[->] (2) edge [bend left] node[right] {$b$} (4);
        \path[->] (4) edge [bend left] node[left] {$b$} (2);
    \end{tikzpicture}
\end{center}

Имаме един брояч от $\mathcal{A}_1$ за четността на $a$ и още един броят от $\mathcal{A}_2$ за четността на $b$.
Можем вземем и двата брояча и единят да се променя само при четена на $a$ (долния брояч), а другият само при четене на $b$ (горния брояч).
Накрая понеже искаме думата да има четен брой $a$ и нечетен брой $b$, искаме отгоре да седи $1$, а отдолу да седи $0$.

Оказва се, че това, което направихме, може да се обобщи ето така:

\begin{claim}
    Ако $L_1$ и $L_2$ са автоматни езици, то $L_1 \cap L_2$ също е автоматен език.
\end{claim}

\begin{proof}
    Нека $\mathcal{A}_1 = \opair{\Sigma, Q_1, s_1, \delta_1, F_1}$ е автомат за $L1$ и нека $\mathcal{A}_2 = \opair{\Sigma, Q_2, s_2, \delta_2, F_2}$ е автомат за $L_2$.
    Строим автомат за сечението:
    \begin{itemize}
        \item $\mathcal{A} = \opair{\Sigma, Q, s, \delta, F}$
        \item $Q = Q_1 \cross Q_2$
        \item $s = \opair{s_1, s2}$
        \item $\delta(\opair{p_1, p_2}, x) = \opair{\delta_1(p_1, x), \delta_2(p_2, x)}$ за $\opair{p_1, p_2} \in Q, \: x \in \Sigma$
        \item $F = F_1 \cross F_2$
    \end{itemize}

    Тук използваме, че двата автомата, които имаме по начало ни дават информация за структурата на думите.
    Ние паралелно изпълняваме четене в $\mathcal{A}_1$ и $\mathcal{A}_2$,
    и накрая искаме положителен отговор и от двата автомата.
    За да покажем, че $\mathcal{L(A)} = L_1 \cap L_2$, ще докажем:
    \begin{claim}
        $\delta^*(\opair{p_1, p_2}, \alpha) = \opair{\delta_1^*(p_1, \alpha), \delta_2^*(p_2, \alpha)}$
    \end{claim}
    \begin{proof}
        С индукция по $|\alpha|$.
        \begin{itemize}
            \item $\delta^*(\opair{p_1, p_2}, \varepsilon) = \opair{p_1, p_2} = \opair{\delta_1^*(p_1, \varepsilon), \delta_2^*(p_2, \varepsilon)}$ \checkmark
            \item $\delta^*(\opair{p_1, p_2}, \beta x) = \delta(\delta^*(\opair{p_1, p_2}, \beta), x) \stackrel{\text{ИП}}{=} \delta(\opair{\delta_1^*(p_1, \beta), \delta_2^*(p_2, \beta)}, x) = \opair{\delta_1(\delta_1^*(p_1, \beta), x), \delta_2(\delta_2^*(p_2, \beta), x)} = \opair{\delta_1^*(p_1, \beta x), \delta_2^*(p_2, \beta x)}$
        \end{itemize}
    \end{proof}

    Имайки това изкарваме директно, че
    $\alpha \in \mathcal{L(A)} \iff \delta^*(s, \alpha) \in F \iff \opair{\delta_1^*(s_1, \alpha), \delta_2^*(s_2, \alpha)} \in F_1 \cross F_2 \iff \delta_1^*(s_1, \alpha) \in F_1 \: \& \: \delta_2^*(s_2, \alpha) \in F_2 \iff \alpha \in L_1 \: \& \: \alpha \in \L_2 \iff \alpha \in L_1 \cap L_2$, с което сме готови.
\end{proof}

Имайки, че $\cap$ и допълнение запазват автоматност, директно изкарваме, че $\cup$ и $\setminus$ запазват автоматност:
\begin{itemize}
    \item $L_1 \cup L_2 = \overline{\overline{L_1 \cup L_2}} = \overline{\overline{L_1} \cap \overline{L_2}}$ \\
          Друг вариант това да се направи е да се приложи същата конструкция, със разликата че $F = (F_1 \cross Q_2) \cup (Q_1 \cross F_2)$
    \item $L_1 \setminus L_2 = L_1 \cap \overline{L_2}$ \\
          Друг вариант това да се направи е да се приложи същата конструкция, със разликата че $F = F_1 \cross (Q_2 \setminus F_2)$
\end{itemize}

\section{Недетерминирани автомати}

\section{Още операции}

\section{Еквивалентност на детерминирани и недетерминирани автомати}

\section{Автомат на Brzozowski}

\section{Неавтоматни езици}

\section{Задачи за упражнение}